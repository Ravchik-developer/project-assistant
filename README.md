##Шпаргалка по Git и GitHub

1. Первым делом создаем локальный репозиторий Git в папке с проектом командой:  
git init

2. Затем добавляем файлы, с которыми будем работать (изменять их) командой:  
git add <имя файла> <имя файла2>... (можно вместо имен сразу все файлы --all)

3. Вносим изменения в файле1 и затем выполняем команду:  
git add <файл1>

4. Затем делаем коммит командой:  
git commit -m "<пишем описание изменений>"

5. Для просмотра состояния пользуемся командой на любом этапе:  
git status

6. Для просмотра истории коммитов используем команду:  
git log

7. Создаем удаленный репозиторий на GitHub (Можно сделать параллельно с локальным)

8. Делаем SSH ключ (муторное дело), если его нет и коннектим локальный и удаленный репозитории:  
git remote add origin <путь который в GitHub возле https|ssh прописываем>  
origin - это стандартный псевдоним, с помощью которого можно обращаться к главному  
репозиторию (обычно главный репозиторий один)

9. Убедимся, что удаленный и локальный репозитории связаны командой:  
git remote -v (выведет 2 строки)

10. Синхронизируем изменения (commits) с удаленным репозиторием командой:  
git push -u origin master|main (при первой синхронизации)  
git push (при последующих)

11. При вызове команды git log выводится информация о коммитах:  
хеш коммита;  
автор коммита + его почта;  
дата создания коммита;
написанный message.

12. Получить сокращенный log можно командой:  
git log --oneline (используется если коммитов очень много)

При вызове git log можно заметить надпись (HEAD -> master) после хеша  
хеша одного из коммитов. ФАЙЛ HEAD - один из служебных файлов папки .git  
Он указывает  на коммит, который сделан последним (он самый новый)  
Многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать  
последний коммит, то вместо его хеша можно просто написать слово HEAD - Git  
поймет, что вы имели ввиду последний коммит 

#**Статусы**
Одна из ключевых задач Git — отслеживать изменения файлов в репозитории.  
Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.
**untracked** Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые.  
Git «видит», что такой файл существует, но не следит за изменениями в нём.  
У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
**staged** После выполнения команды git add файл попадает в staging area  
(от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов,  
которые войдут в коммит. В этот момент файл находится в состоянии staged.
**tracked** Состояние tracked — это противоположность untracked.  
Оно довольно широкое по смыслу: в него попадают файлы, которые уже были  
зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add.  
То есть все файлы, в которых Git так или иначе отслеживает изменения.
**modified** Состояние modified означает, что Git сравнил  
содержимое файла с последней сохранённой версией и нашёл отличия.  
Например, файл был закоммичен и после этого изменён.

Для файлов в состояниях staged и modified обычно не указывают,  
что они также tracked, потому что это состояние подразумевается.
(картинку с циклом жизни файла в Git ты скачивал, позырь его)

Есть общие рекомендации по тому, как правильно составить сообщение коммита. 
Оно должно быть: относительно коротким, чтобы его было легко прочитать; информативным.  
Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов.  
Кто-то использует инфинитивы: Исправить сообщение об ошибке E123,  
кто-то — глаголы в прошедшем времени: Исправил…, кто-то — существительные: Исправление….
Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле  
(то есть о правилах) оформления сообщений коммитов.
Популярные подходы к оформлению сообщений коммитов:
**Корпоративный** - Во многих компаниях применяется Jira — система для организации проектов и задач.  
У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера.  
Например, LGS-239 значит, что это 
239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).  
В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.  
git commit -m "LGS-239: Дополнить список пасхалок новыми числами"  
**Conventional Commits** - отличается качественной документацией и подробной проработкой.  
Он подходит для репозиториев с исходным кодом программ.  
Использовать его для других типов проектов (например, для перевода книги) было бы неудобно.
Предлагает такой формат коммита: <type>: <сообщение>. Первая часть type — это тип изменений.
git commit -m "feat: добавить подсчёт суммы заказов за неделю"
**GitHub-стиль** GitHub можно использовать не только для хранения файлов проекта,  
но и для ведения списка задач (англ. issue) этого проекта.  
Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё.  
Для этого в любом месте сообщения нужно указать #<номер задачи>.  
Например, вот так: git commit -m "Исправить #334, добавить график температуры" 

ВСЕ СВОИ СООБЩЕНИЯ КОММИТА ОФОРМЛЯЙ В ОДНОМ СТИЛЕ

Исправление коммита с помощью --amend (работает только с HEAD)  
После добавления коммита, если забыли в него включить какой-то файл  
То этот файл добавляем командой git add <файл> и обновляем последний (HEAD)  
коммит командой: git commit --amend --no-edit  
--no-edit сообщает, что сообщение изменяемого коммита нужно оставить без изменений  
Также можно менять файл в коммите таким же способом, который указан выше,  
а не только добавлять файл в HEAD коммит
Можно менять сообщение HEAD коммита командой:  
git commit --amend -m "Новое сообщение"